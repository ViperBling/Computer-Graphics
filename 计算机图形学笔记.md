[TOC]

# Chapter01. 引言

# Chapter02. 数学知识

## 2.1 集合与映射

## 2.2 解二次方程

## 2.3 三角学

三角函数

## 2.4 向量

### 2.4.3 点积

通过点积计算向量夹角。

### 2.4.4 叉积

图形学中叉积一般用于判断向量的相对位置和点相对向量的位置

## 2.5 二维隐式曲线

简单来说就是二元函数的隐式方程。

## 2.6 二维参数曲线

二维曲线的参数方程。

## 2.7 三维隐式曲面

## 2.10 线性插值

## 2.11 三角形

过三点的三角形面积公式：

![image-20200528155231990](计算机图形学笔记.assets/image-20200528155231990.png)

图形学中，经常用三点的值的某一性质（例如颜色）插值到三角形中。最简单的就是利用重心。可以建立重心坐标系：

![image-20200528155439298](计算机图形学笔记.assets/image-20200528155439298.png)

# Chapter03. 光栅算法

## 3.1 光栅显像

编程人员通常假设像素按矩形排列，称为光栅（raster）。

以整数点作为像素中心：

![image-20200528160745477](计算机图形学笔记.assets/image-20200528160745477.png)

## 3.2 显示器亮度和$\gamma$值

显示器对输入信号的处理是非线性的，输入的像素值为0、0.5、1.0，实际亮度可能是0、0.25、1.0。一般用$\gamma$值来近似非线性：
$$
显示亮度=(最大亮度)a^{\gamma}
$$
其中$a$是介于0，1之间的亮度值。

![image-20200528162644873](计算机图形学笔记.assets/image-20200528162644873.png)

## 3.3 RGB颜色

![image-20200528162558870](计算机图形学笔记.assets/image-20200528162558870.png)

类似灰度值，RGB也是在$0~1$之间的分数，可以构建一个RGB立方体，里面所有的点就是色域：

![image-20200618165352052](计算机图形学笔记.assets/image-20200618165352052.png)

## 3.4 $\alpha$通道

对于有前景和背景的图片来说，如果前景不透明，那么只需要用前景替换对应位置的像素即可；如果前景完全透明，那么只显示背景即可。对于半透明的前景，就要权衡前景像素和背景像素的RGB比例，即$\alpha$分数。如果想把前景色$c_f$和背景色$c_b$混合，被前景覆盖的像素的分数是$\alpha$，那么有：
$$
c=\alpha c_f+(1-\alpha)c_b
$$

## 3.5 直线绘制

### 3.5.1 基于隐式方程绘制直线

绘制两点$(x_0,y_0),(x_1,y_1)$之间的一条直线，找到隐式方程：
$$
f(x,y) = (y_0-y_1)x+(x_1-x_0)y+x_0y_1-x_1y_0=0
$$
直线的斜率是：
$$
m=\frac{y_1-y_0}{x_1-x_0}
$$








# Chapter06. 矩阵变换

## 6.1 基本二维变换

包括缩放、切变、旋转、镜像（反射）

### 6.1.2 切变

$$
shear_x(s)=\begin{bmatrix}
1 & s \\ 0 & 1
\end{bmatrix}, 
shear_y(s)=\begin{bmatrix}
1 & 0 \\ s & 1
\end{bmatrix}
$$

将图像在水平或者垂直方向上倾斜：

![image-20200604154243475](计算机图形学笔记.assets/image-20200604154243475.png)

### 6.1.3 旋转

固定旋转点是原点，得到旋转矩阵：
$$
rotate(\phi) = \begin{bmatrix}
\cos\phi & -\sin\phi \\ \sin\phi & \cos\phi
\end{bmatrix}
$$
旋转矩阵都是正交阵。

### 6.1.5 二维变换组合

例如先旋转$R$后缩放$S$，对于一个向量$\vec v$来说，首先旋转，$\vec {v_1} = R\vec v$，然后缩放，$\vec{v_2}=S\vec{v_1}$ ，结合起来就是$\vec{v_2}=SR\vec{v}$，也就是说两个矩阵的变换效果可以通过一个矩阵表示出来。

### 6.1.6 二维变换分解

对于一个矩阵，可以将其拆成多个矩阵相乘的形式，每个矩阵对应了一个变换。任何二维矩阵都可以分解成旋转、缩放、旋转三种矩阵之积。这个过程可以通过奇异值分解实现，一个二维矩阵的奇异值分解的结果就是旋转矩阵和缩放矩阵的乘积：

![image-20200604155215198](计算机图形学笔记.assets/image-20200604155215198.png)

![image-20200604155224510](计算机图形学笔记.assets/image-20200604155224510.png)

另外一种分解的方法就是通过切变表示旋转：

![image-20200604155324197](计算机图形学笔记.assets/image-20200604155324197.png)

![image-20200604155334307](计算机图形学笔记.assets/image-20200604155334307.png)

## 6.2 基本三维变换

基本和二维类似，旋转稍微复杂一点，因为旋转轴较多，可以绕三个坐标轴旋转，事实上，绕这三个轴旋转即可将物体旋转到任意角度。

### 6.2.1 任意三维旋转

对于一个3维正交阵代表的旋转矩阵，它的每个行向量都是标准正交基，矩阵和基相乘，也就是变换的结果是将三个基旋转到笛卡尔坐标系中：

![image-20200604160138616](计算机图形学笔记.assets/image-20200604160138616.png)

即将坐标轴$\boldsymbol{uvw}$，旋转到$\boldsymbol {xyz}$上。同时矩阵$R_{uvw}$的逆矩阵（转置矩阵）就是对应旋转的逆变换。

如果要绕任意向量$\boldsymbol a$进行旋转，可以先构造一个正交基$\boldsymbol w=\boldsymbol a$，然后将这个正交基旋转到$\boldsymbol{xyz}$，然后绕$\boldsymbol z$旋转，再把标准基旋转回$\boldsymbol {uvw}$。

### 6.2.2 法向量变换

三维表面的切向量变换后仍然相切，但是法向量却不一定垂直：

![image-20200604161200561](计算机图形学笔记.assets/image-20200604161200561.png)

![image-20200604161423364](计算机图形学笔记.assets/image-20200604161423364.png)

## 6.3 平移

所有以上的变换都可以表示成一个矩阵乘以一个向量的形式，但是平移变换却不能这么表示。为了解决这个问题，我们可以将变换置于更高的维度，在向量和点中添加一个维度来完成统一的表示。

![image-20200604161829880](计算机图形学笔记.assets/image-20200604161829880.png)

另外一个就是窗口变换，我们需要将一个矩形中的点变换到另外一个矩形中，可以通过缩放然后平移两次完成，也可以通过三个步骤完成：

- 将矩形移动到原点
- 缩放到目标矩形的大小
- 然后将原点移动到目标矩形的左下角

![image-20200609170003931](计算机图形学笔记.assets/image-20200609170003931.png)

# Chapter07. 观察

这里解决的问题就是将三维空间中的点或者物体如何显示到对应的屏幕上。

## 7.1 绘制标准视体

现在我们要将直线沿着z轴的正方向映射到屏幕上。为此设置一个标准视体，就是边长为2，中心点在原点的立方体：

![image-20200609165714952](计算机图形学笔记.assets/image-20200609165714952.png)

假设屏幕大小是$n_x \times n_y$，每个像素有0.5个单位的过冲，左下角在原点，像素中心为$(0,0)$，屏幕的边界为$[-0.5,n_x-0.5]\times[-0.5,n_y-0.5]$（两个坐标轴的边界）。这和上面的窗口变换是一样的（先将原来标准视体的矩形移动到原点，然后缩放到屏幕大小，然后将原点移动到左下角像素中心）。变换式为：

![image-20200609170436769](计算机图形学笔记.assets/image-20200609170436769.png)

这个过程其实就是将标准视体这个方形框转换到成屏幕这个大矩形中。

## 7.2 正射投影

正射投影在现实中平行的线段在投影视图中还是平行的。如果要将一个空间中的线段转换到标准视体中，需要一个投影矩阵：

![image-20200610162019679](计算机图形学笔记.assets/image-20200610162019679.png)

这里将$y=b$变成$y=-1$，$y=t\rightarrow y=1$；$x=l\rightarrow -1$；$z=n\rightarrow z=1, z=f\rightarrow z=-1$.变换公式如下：

![image-20200610162218955](计算机图形学笔记.assets/image-20200610162218955.png)

先缩放后平移或者先平移后缩放。

为了将三维线段绘制在屏幕上，可以结合7.1中的矩阵实现转换：

![image-20200610162340767](计算机图形学笔记.assets/image-20200610162340767.png)

这样就可以将空间坐标系中的三维点转换到可以显示的屏幕上了。

### 任意视点

在空间的任意一个位置观察物体，规定：

- 眼睛位置$\boldsymbol e$
- 眼睛看的方向$\boldsymbol g$
- 向上的向量$\boldsymbol t$

![image-20200610162558063](计算机图形学笔记.assets/image-20200610162558063.png)



通过这三个坐标可以建立一个标准正交系$\boldsymbol {uvw}$：
$$
\begin{align}
{\boldsymbol w} &= -\frac{\boldsymbol g}{||\boldsymbol g||}\\
{\boldsymbol u} &= \frac{{\boldsymbol t}\times {\boldsymbol w}}{||{\boldsymbol t}\times {\boldsymbol w}||}\\
{\boldsymbol v} &= {\boldsymbol w} \times {\boldsymbol u}
\end{align}
$$
我们要解决的问题是将$\boldsymbol {uvw}$中的点转换到${\boldsymbol {xyz}}$中，然后显示在屏幕上，可以先将$\boldsymbol e$移动到原点，然后将坐标轴位置摆正就可以了。因为在坐标移动的过程中，$\boldsymbol {uvw}$中的物体也是随着坐标系一起移动的，最后得到的就是物体相对于$\boldsymbol {xyz}$的相对位置。

![image-20200610164702607](计算机图形学笔记.assets/image-20200610164702607.png)

![image-20200610164712205](计算机图形学笔记.assets/image-20200610164712205.png)

## 7.3 透视投影

相比于正射投影，透视投影有一个特点就是近大远小。透视投影将物体直接向眼睛投影，并画在投影线与眼睛前面的观察平面相交的位置。

![image-20200610164937621](计算机图形学笔记.assets/image-20200610164937621.png)

将观察点放在原点，向$z$轴负方向观察，物体大小和$z$轴坐标成反比：$y_s=\frac dz y$：

![image-20200610165214148](计算机图形学笔记.assets/image-20200610165214148.png)

我们希望像正射投影那样，建立一个矩阵机制来绘制图像。这里z轴的坐标可以不用关心，因为正射投影的时候会忽略z值。

将观察平面设置为$z=n$，然后按照光线将后面的大矩形缩放到正射投影的小矩形上。这一步的特点就是将之前所有通过观察点的直线全部变换成平行线。

![image-20200611160525022](计算机图形学笔记.assets/image-20200611160525022.png)

![image-20200611160755038](计算机图形学笔记.assets/image-20200611160755038.png)

上面说过，这一步需要除以$z$来实现，可以通过第四维的齐次坐标来实现这个过程。第4维坐标表示了其他三个坐标轴的缩放程度，齐次化的过程中除以第4维坐标就能得到真实位置：

![image-20200611161616750](计算机图形学笔记.assets/image-20200611161616750.png)

矩阵$M_p$作用在点$(x,y,z)$上的结果就是像上图7-11，7-12那样，$z=n$的平面点不变，$z=f$平面按照一定比例压缩，矩阵变换如下：

![image-20200611162102025](计算机图形学笔记.assets/image-20200611162102025.png)

这就实现了除以$z$的目的。由于对齐次矩阵乘以一个常数，其结果并不会发生变话，所以可以用$n*M_p$得到一个更规整的矩阵。

综合上面的描述，我们得到了透视观察的矩阵集：
$$
\boldsymbol M={\boldsymbol M}_o{\boldsymbol M}_p{\boldsymbol M}_v
$$
其中${\boldsymbol M}_o{\boldsymbol M}_p$是投影矩阵。





